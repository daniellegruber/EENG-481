function [ds, qInterp] = genConfigTrajectoryFromInput(signSeq, jointNames, transitionTbl)
nJoints = length(jointNames);

letterNames = cell(1,26);
letterStr = 'a':'z';
for i = 1:26
    letterNames{i} = letterStr(i);
end
letterNames = addLetterPrefix(letterNames);

% Init qWaypoints, tWaypoints
movingSigns = {'letter_j', 'letter_z'}; 
movingSignTWaypoints = {[0 0.5 1], [0 0.5 1 1.5]};
nMax = 100;
qWaypoints = zeros(nMax, nJoints);
tWaypoints = zeros(nMax, 1);

% Iterate over sign sequence
timeBetweenSigns = 1.5;
timeHoldSign = 0.5;
%timeToReachTransitionWaypoint = 0.5;

waypointEndIdx = 0;
tEndOfPrevSign = 0;
for i = 1:length(signSeq)

    firstZOfDoubleZFlag = 0;
    if i < length(signSeq) && strcmp(signSeq{i}, 'letter_z') && strcmp(signSeq{i+1}, 'letter_z')
        firstZOfDoubleZFlag = 0;
    end

    % if i > 1 && strcmp(signSeq{i}, 'letter_z') && strcmp(signSeq{i-1}, 'letter_z')
    % end
    sign_name = signSeq{i};
    load(['Configs', filesep, sign_name, '.mat'], 'jointValues');
    jointValues = correctJointValueDims(jointValues, nJoints);
    
    % Update tWaypoints
    waypointStartIdx = waypointEndIdx  + 1;
   
    movingIdx = find(ismember(movingSigns, signSeq{i}));

    transitionFlag = 0;
    transitionNames = {};
    transitionProps = 0; % proportion of way between two signs to insert waypoint
    nTransitionPoints = 0;
    if i < length(signSeq)
        transitionTblIdx = [find(ismember(letterNames, signSeq{i})), find(ismember(letterNames, signSeq{i+1}))];
        if ~isempty(transitionTbl{transitionTblIdx(1), transitionTblIdx(2)})
            transitionFlag = 1;
            transitionNames = transitionTbl{transitionTblIdx(1), transitionTblIdx(2)}{1};
            transitionProps = transitionTbl{transitionTblIdx(1), transitionTblIdx(2)}{2};
            nTransitionPoints = length(transitionProps);
        end
    end

    % Moving sign
    if ~isempty(movingIdx) 
        tPoints = movingSignTWaypoints{movingIdx};
        tPoints = [tPoints, tPoints(end) + timeHoldSign];
        tEndOfCurrSign = tEndOfPrevSign + timeBetweenSigns + tPoints(end);
        if transitionFlag
            %tPoints = [tPoints, tPoints(end) + timeToReachTransitionWaypoint];
            tPoints = [tPoints, tPoints(end) + transitionProps * timeBetweenSigns];
        end
        jointValues = [jointValues; jointValues(end, :)];
    elseif transitionFlag
        tEndOfCurrSign = tEndOfPrevSign + timeBetweenSigns + timeHoldSign;
        %tPoints = [0, timeHoldSign, timeHoldSign + timeToReachTransitionWaypoint];
        tPoints = [0, timeHoldSign, timeHoldSign + transitionProps * timeBetweenSigns];
        jointValues = [jointValues; jointValues];
    else 
        tEndOfCurrSign = tEndOfPrevSign + timeBetweenSigns + timeHoldSign;
        tPoints = [0, timeHoldSign];
        jointValues = [jointValues; jointValues];
    end

    waypointEndIdx = waypointStartIdx + length(tPoints) - 1;
    if i == 1
        tWaypoints(waypointStartIdx:waypointEndIdx) = tPoints;
    else
        tWaypoints(waypointStartIdx:waypointEndIdx) = tEndOfPrevSign + tPoints;
    end

    % If repeated letter, slide to right or left depending on hand
    if i > 1 && strcmp(signSeq{i}, signSeq{i-1})
        slideJointIdx = ismember(jointNames, 'ARMJ2');
        jointValues(:, slideJointIdx) = 0.1;
    end

    % If previous letter had thumb inside, insert another waypoint to allow
    % fingers to move without cross
    
    if transitionFlag
        for j = 1:nTransitionPoints
        jointValues2 = jointValues;
        load(['Configs', filesep, transitionNames{j}, '.mat'], 'jointValues');
        jointValues3 = correctJointValueDims(jointValues, nJoints);
        jointValues = [jointValues2; jointValues3];
        end
    end

    % Update qWaypoints
    qWaypoints(waypointStartIdx:waypointEndIdx,:) = jointValues; 
    tEndOfPrevSign = tEndOfCurrSign;
end

qWaypoints = qWaypoints(1:waypointEndIdx, :);
tWaypoints = tWaypoints(1:waypointEndIdx, :);

Ts = 0.001; % sample time
tFinal = tWaypoints(end);

diff1 = abs(diff(qWaypoints, 1));
diff2 = abs(diff(wrapTo2Pi(qWaypoints), 1));
wrapTo2PiIdx = round(diff2, 4) < round(diff1, 4);
qWaypoints2 = qWaypoints(2:end, :);
qWaypoints2(wrapTo2PiIdx) = wrapTo2Pi(qWaypoints2(wrapTo2PiIdx));
qWaypoints2 = [qWaypoints(1,:); qWaypoints2];

qInterp = pchip(tWaypoints,qWaypoints2',0:Ts:tFinal);

ds = jointValuesToInputSignals(qInterp, jointNames, Ts, tFinal, '');

    
function signSeq = addLetterPrefix(letterCell)
    signSeq = cellfun(@(x) ['letter_', x], letterCell, 'UniformOutput', false);
end

function jointValues = correctJointValueDims(jointValues, nJoints)
    jointDim = find(size(jointValues) == nJoints);
    if jointDim ~= 2
        jointValues = jointValues';
    end
end

end