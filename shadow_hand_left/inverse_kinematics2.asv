%% Create target pose of each finger tip, one by one
% For each of the four non-thumb fingers, get a "curled in" finger by 
% trying to get the finger tip (lftip, rftip, mftip, fftip) as close to the
% palm as possible, and orienting it so that its z-axis roughly points into 
% the palm

fingerNames = {'LF', 'RF', 'MF', 'FF', 'TH'};
rbt = shadow_hand_right_rbt;
q0 = homeConfiguration(rbt);
valuesPrev = q0;


for fingerIdx = 1:4
%% Set parameters
% Proportion of y-distance from palm ref frame to lftip ref frame to
% have y value of lftip
yprop = 0.8;

% Proportion of z-distance from palm ref frame to lfknuckle ref frame to
% have z value of lftip
zprop = 0.3;

%% Set up target pose of lftip

tip_frame = [lower(fingerNames{fingerIdx}),'tip'];
knuckle_frame = [lower(fingerNames{fingerIdx}),'knuckle'];

% Get transforms of certain frames relative to world in home config
tip_to_world = se3(getTransform(rbt,q0,tip_frame,"world"));
lfknuckle_to_world = se3(getTransform(rbt,q0,knuckle_frame,"world"));
palm_to_world = se3(getTransform(rbt,q0,"palm","world"));

% Create target translation
trvec_palm = trvec(palm_to_world); 
trvec_tip = trvec(lftip_to_world); 
trvec_knuckle = trvec(lftip_to_world); 
trvec_new = trvec_palm;
trvec_new(2) = trvec_palm(2) + yprop*(trvec_tip(2) - trvec_palm(2)); 
trvec_new(3) = trvec_palm(3) + zprop*(trvec_knuckle(3) - trvec_palm(3));
T1 = se3(trvec_new, "trvec");

% Get target rotation
% Get home config orientation of lftip relative to world
R1 = se3(rotm(tip_to_world)); 
% By inspection, we see that we need to rotate around by x axis by 270 deg to get z axis of lftip pointing in -x direction of world frame
% Make a little less than 270 so that it's more realistic
R2 = se3([deg2rad(250), 0, 0],"eul","XYZ"); 

% Create target pose
targetPose = T1 * R1 * R2;

%% Create solver
gik = generalizedInverseKinematics('RigidBodyTree', rbt, ...
    'ConstraintInputs', {'pose','joint'});

% gik = generalizedInverseKinematics('RigidBodyTree', shadow_hand_right_rbt, ...
%     'ConstraintInputs', {'pose','joint'}, 'SolverAlgorithm','LevenbergMarquardt');

% gik = generalizedInverseKinematics('RigidBodyTree', shadow_hand_left_rbt, ...
%     'ConstraintInputs', {'cartesian','position','aiming','orientation','joint'});

% Solver parameters
% gik.SolverParameters.MaxIterations = 1500;
gik.SolverParameters.MaxTime = 2;

% Joint constraints -- only want little finger lf to move
jointLimits = constraintJointBounds(shadow_hand_right_rbt);
oldBounds = jointLimits.Bounds;
upperBounds = oldBounds(:,2);
lowerBounds = oldBounds(:,1);
% Fix non-finger joints to values obtained from previous iteration
nonFingerIdx = ~startsWith(jointNames,fingerNames{fingerIdx});
upperBounds(nonFingerIdx) = valuesPrev(nonFingerIdx); 
lowerBounds(nonFingerIdx) = valuesPrev(nonFingerIdx); 
jointLimits.Bounds = [lowerBounds, upperBounds];
jointLimits.Weights = 10 * ones(1, 24);

% End effector pose contraints
%lftip_pos = constraintCartesianBounds('lftip', 'ReferenceBody', 'world');
lftip_pos = constraintPoseTarget('lftip', 'ReferenceBody', 'world');
lftip_pos.TargetTransform = tform(targetPose);
lftip_pos.OrientationTolerance = deg2rad(10); % allow more leeway for orientation
lftip_pos.PositionTolerance = 0;
lftip_pos.Weights = [1, 1]; % PositionTolerance and OrientationTolerance
%lftip_pos.Bounds = [0.01, 0.03; 0.03, 0.034; 0.25, 0.35];

% Initial config
q0=homeConfiguration(shadow_hand_right_rbt);

%% Run solver
[qSol, solutionInfo] = gik(q0, lftip_pos, jointLimits);
solJointValues = vertcat(qSol.JointPosition);
solJointValues(abs(solJointValues) < 1e-3)=0;

% qSol = gik(q0, lftip_pos, jointLimits);
% figure;
% show(shadow_hand_left_rbt,qSol) % for some reason this doesn't show the right joint values

%% Create signals to provide to right_test_asl_poses.slx
jointValuesToInputSignals(solJointValues, jointNames, 0.001, 2, ...
     ['signals_after_solving_', fingerNames{fingerIdx}]);

% jointValuesToInputSignals(solJointValues, jointNames, 0.001, 2, ...
%     ['signals ', char(datetime('now', 'Format', 'd-MMM-y HH-mm-ss'))]);
end


